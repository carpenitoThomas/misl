# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
library("packrat")
library('mice')
library('misl')
library('dplyr')
library("sl3")
abalone <- read.csv("abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
dplyr::mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- dplyr::tibble(abalone)
data(abalone)
abalone
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
dplyr::mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- dplyr::tibble(abalone)
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
#plan(list(tweak(multisession, workers = 5),tweak(multisession, workers = 3)))
misl_imputations <- misl(amputed_data,
con_method = c("Lrnr_mean"),
bin_method = c("Lrnr_mean"),
cat_method = c("Lrnr_mean"))
#cat_method = c("Lrnr_mean", "Lrnr_glmnet", "Lrnr_independent_binomial", "Lrnr_randomForest"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
simulation_results_multicore <- system.time(simulation(1, multisession = TRUE))
simulation_results_multicore
load_all()
?mice
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
dplyr::mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- dplyr::tibble(abalone)
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean", print = FALSE)
mice_imputations <- mice(amputed_data, print = FALSE)
#plan(list(tweak(multisession, workers = 5),tweak(multisession, workers = 3)))
misl_imputations <- misl(amputed_data,
con_method = c("Lrnr_mean"),
bin_method = c("Lrnr_mean"),
cat_method = c("Lrnr_mean"))
#cat_method = c("Lrnr_mean", "Lrnr_glmnet", "Lrnr_independent_binomial", "Lrnr_randomForest"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
simulation_results_multicore <- system.time(simulation(1))
simulation_results_multicore
system.time(simulation(2))
plan(list(tweak(multisession, workers = 5), sequential))
simulation_results_multicore <- system.time(simulation(1))
library("future")
plan(list(tweak(multisession, workers = 5), sequential))
simulation_results_multicore <- system.time(simulation(1))
simulation_results_multicore
?install_github
load("/Users/thomascarpenito/Downloads/simulation_results_multicore.Rdata")
simulation_results_multicore
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (1).Rdata")
simulation_results_multicore
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (2).Rdata")
simulation_results_multicore
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (3).Rdata")
simulation_results_multicore
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (5).Rdata")
simulation_results_multicore
238 - 50
188 / 60
238 / 60
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (6).Rdata")
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (7).Rdata")
# Original learners...
simulation_results_multicore
load("/Users/thomascarpenito/Downloads/simulation_results_multicore_more.Rdata")
load("/Users/thomascarpenito/Downloads/simulation_results_multicore (8).Rdata")
simulation_results_multicore_more
load("/Users/thomascarpenito/Downloads/simulation_results_multicore.Rdata")
simulation_results_multicore
41.92/60
(41.92/60)*1000
(41.92/60/60)*1000
((41.92/60/60)*1000)/2
((41.92/60/60)*200)/2
library("misl")
dataset <- nhanes
datset
dataset
maxit = 2
con_method = c("Lrnr_mean", "Lrnr_glm")
bin_method = c("Lrnr_mean", "Lrnr_glm")
cat_method = c("Lrnr_mean", "Lrnr_glmnet")
missing_default = "mean",
missing_default = "mean"
quiet = TRUE
# Identify which order the columns should be imputed.
# The order here specifies least missing data to most though the order should not be important (per MICE).
column_order <- colnames(dataset)[order(colSums(is.na(dataset)))]
# Retain a copy of the dataset for each of the new m datasets
dataset_master_copy <- dataset
column
column_order
column <- "Education"
# First, we extract all complete records with respect to the column we are imputing
# Note, with the second iteration we should be using *all* rows of our dataframe (since the missing values were imputed on the first iteration)
full_dataframe <- dataset_master_copy[!is.na(dataset_master_copy[[column]]), ]
# Next identify the predictors (xvars) and outcome (yvar) depending on the column imputing
xvars <- colnames(full_dataframe[ , -which(names(full_dataframe) %in% c(column)), drop = FALSE])
yvar <- column
xvars
yvar
# For the first iteration, any missing values will need to be set to either the mean or mode of the column.
# This will also serve as a "catch" if the algorithm chooses not to impute values for this column as well upon successive iterations.
# Note, we include the "yvar" in this iteration though nothing should be imputed for this column (since we subsetted with respect to it being full)
# It would be easy to define this column type as a variable.
for(column_number in seq_along(full_dataframe)){
full_dataframe[is.na(full_dataframe[[column_number]]), column_number] <-  impute_placeholders(full_dataframe, column_number, missing_default)
}
# Specifying the outcome_type will be helpful for checking learners.
outcome_type <- check_datatype(dataset[[yvar]])
check_dataset <- function(dataset){
if(sum(colSums(is.na(nhanes))) == 0){
stop("Your dataset is complete, no need for MISL!")
}
}
check_datatype <- function(x){
datatype <- class(x)
if(class(x) == "factor"){
return("categorical")
}
else{
# We assume now that we have some continuous variable... BUT this variable could be binary or continuous
# Major assumption, if the column is binary then it must ONLY have the values 0,1 (not 1,2 - for example)
# This function is incomplete in its checks...
if(length(levels(as.factor(x))) == 2){
return("binary")
}else{
# Here, we assume a continuous variable and can use simple mean or median imputation
return("continuous")
}
}
}
# Specifying the outcome_type will be helpful for checking learners.
outcome_type <- check_datatype(dataset[[yvar]])
outcome_type
library("sl3")
# First, define the task
task <- sl3::make_sl3_Task(full_dataframe, covariates = xvars, outcome = yvar)
cat_method
# Depending on the outcome, we need to build out the learners
learners <- switch(outcome_type,
categorical = cat_method,
binary = bin_method ,
continuous = con_method)
# Next, iterate through each of the supplied learners to build the SL3 learner list
learner_list <- c()
for(learner in learners){
code.lm <- paste(learner, " <- sl3::", learner, "$new()", sep="")
eval(parse(text=code.lm))
learner_list <- c(learner, learner_list)
}
# Next we stack the learners
learner_stack_code <- paste("stack", " <- sl3::make_learner(sl3::Stack,",paste(learner_list, collapse = ", "), ")", sep="")
eval(parse(text=learner_stack_code))
# Then we make and train the Super Learner
# This was a bottleneck for past simulations and we are introducing multisession parellelization
sl <- sl3::Lrnr_sl$new(learners = stack)
# Technically I should be able to just include the delayed code and the plan should default to sequential?
test <- sl3::delayed_learner_train(sl, task)
sched <- delayed::Scheduler$new(test, delayed::FutureJob, verbose = !quiet)
stack_fit <- sched$compute()
i_loop
i_loop = 1
####### CAN I KEEP JUST THE FOLLOWING CODE AND REMOVE THE IF/ELSE CONDITIONAL?
# And finally obtain predictions from the stack on the updated dataset
if(i_loop == 1){
dataset_copy <- dataset_master_copy
for(column_number in seq_along(dataset_copy)){
# This is a check to see if the column is a factor, requiring mode imputation
# This means that the column should be registered as a factor.
column_type <- check_datatype(dataset[[column_number]])
if(column_type == "categorical"){
dataset_copy[is.na(dataset_copy[[column_number]]), column_number] <-  impute_mode(dataset_copy[[column_number]])
}else{
# Major assumption, if the column is binary then it must ONLY have the values 0,1 (not 1,2 - for example)
# This function is incomplete in its checks...
if(column_type == "binary"){
dataset_copy[is.na(dataset_copy[[column_number]]), column_number] <-  impute_mode(dataset_copy[[column_number]])
}else{
# Here, we assume a continuous variable and can use simple mean or median imputation
dataset_copy[is.na(dataset_copy[[column_number]]), column_number] <-  get(missing_default)(dataset_copy[[column_number]], na.rm = TRUE)
}
}
}
}else{
dataset_copy <- full_dataframe
}
new_prediction_task <- sl3::sl3_Task$new(dataset_copy, covariates = xvars, outcome = yvar)
predictions <- stack_fit$predict(new_prediction_task)
outcome_type
as.factor(ifelse(is.na(dataset[[column]]), as.character(sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]])))
stats::rmultinom(length(dataset_master_copy[[column]]), 1, predictions)
predictions
sl3::predict_classes(sl3::unpack_predictions(predictions))
sl3::unpack_predictions(predictions))
sl3::unpack_predictions(predictions)
stats::rmultinom(length(dataset_master_copy[[column]]), 1, sl3::unpack_predictions(predictions))
# In this instance, the column type is categorical
predicted_values <- stats::rmultinom(length(dataset_master_copy[[column]]), 1, sl3::unpack_predictions(predictions))
predicted_values[[1]]
predicted_values
View(predicted_values)
?stats::rmultinom
length(dataset_master_copy[[column]])
dataset_master_copy
nrow(dataset_master_copy)
nrow(dataset)
sl3::unpack_predictions(predictions)
rowSums(sl3::unpack_predictions(predictions))
sl3::unpack_predictions(predictions)
rmultinom(10, size = 12, prob = c(0.1,0.2,0.8))
?rbinom
rmultinom(10, size = 12, prob = c(0.1,0.2,0.8))
rmultinom(10, size = 1, prob = c(0.1,0.2,0.8))
a <- rmultinom(10, size = 12, prob = c(0.1,0.2,0.8))
a
a <- rmultinom(10, size = 1, prob = c(0.1,0.2,0.8))
a
str(sl3::unpack_predictions(predictions))
sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]]))
sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]])
sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]]
sl3::predict_classes(sl3::unpack_predictions(predictions)))
sl3::predict_classes(sl3::unpack_predictions(predictions))
sl3::predict_classes(stats::rmultinom(length(dataset_master_copy[[column]]), 1, sl3::unpack_predictions(predictions)))
stats::rmultinom(length(dataset_master_copy[[column]]), 1, predictions)
stats::rmultinom(length(dataset_master_copy[[column]]), 1, sl3::unpack_predictions(predictions))
sl3::unpack_predictions(predictions)
predicted_values
predicted_values[[1]]
predicted_values[[,1]]
predicted_values[1]
predicted_values[,1]
sum(predicted_values[,1])
?dmultinom
length(predicted_values)
nrow(predicted_values)
predicted_values <- stats::rmultinom(length(dataset_master_copy[[column]]), 1, sl3::unpack_predictions(predictions))
ncol(predicted_values)
predicted_values[,1]
?runiform
?rbinom
runiform
rbinlength(predicted_values)
length(predicted_values)
nrow(predicted_values)
ncol(predicted_values)
predicted_values[,1]
rmultinom(10, size = 12, prob = c(0.1,0.2,0.8))
rmultinom(10, size = 1, prob = c(0.1,0.2,0.8))
predictions
sl3::unpack_predictions(predictions)
library('Hmisc')
rMultinom(sl3::unpack_predictions(predictions),1)
nrow(rMultinom(sl3::unpack_predictions(predictions),1))
nrow(rMultinom(sl3::unpack_predictions(predictions),2))
rMultinom(sl3::unpack_predictions(predictions),2)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
sl3::unpack_predictions(predictions))
sl3::unpack_predictions(predictions)
tail(sl3::unpack_predictions(predictions))
rMultinom(sl3::unpack_predictions(predictions),1)
tail(sl3::unpack_predictions(predictions))
tail(sl3::unpack_predictions(predictions))
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
rMultinom(sl3::unpack_predictions(predictions),1)
?rMultinom
Hmisc::rMultinom(sl3::unpack_predictions(predictions),1)
as.factor(ifelse(is.na(dataset[[column]]), as.character(sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]])))
str(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1))
as.factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1))
levels(as.factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1)))
Hmisc::rMultinom(sl3::unpack_predictions(predictions),1)
as.factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1))
as.factor(ifelse(is.na(dataset[[column]]), as.character(sl3::predict_classes(sl3::unpack_predictions(predictions))), as.character(dataset[[column]])))
levels(dataset[[column]])
factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1), levels = levels(dataset[[column]]))
ifelse(is.na(dataset[[column]]), predicted_values, dataset[[column]])
predicted_values <- factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1), levels = levels(dataset[[column]]))
ifelse(is.na(dataset[[column]]), predicted_values, dataset[[column]])
predicted_values
is.na(dataset[[column]]
)
dataset[[column]]
predicted_values
dataset_master_copy[[column]] <- ifelse(is.na(dataset[[column]]), predicted_values, dataset[[column]])
dataset_master_copy[[column]]
predicted_values <- factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1), levels = levels(dataset[[column]]))
predicted_values
predicted_values <- factor(Hmisc::rMultinom(sl3::unpack_predictions(predictions),1), levels = levels(dataset[[column]]))
dataset_master_copy[[column]] <-  as.factor(ifelse(is.na(dataset[[column]]), predicted_values, dataset[[column]]))
predicted_valuesdataset_master_copy[[column]]
dataset_master_copy[[column]]
(is.na(dataset[[column]]
)
)
predicted_values
str(predicted_values)
dataset[[column]]
Hmisc::rMultinom(sl3::unpack_predictions(predictions),1), levels = levels(dataset[[column]])
Hmisc::rMultinom(sl3::unpack_predictions(predictions),1)
as.character(dataset[[column]])
factor(ifelse(is.na(dataset[[column]]), predicted_values, as.character(dataset[[column]])), levels = levels(dataset[[column]]))
predicted_values <- Hmisc::rMultinom(sl3::unpack_predictions(predictions),1)
dataset_master_copy[[column]] <-  factor(ifelse(is.na(dataset[[column]]), predicted_values, as.character(dataset[[column]])), levels = levels(dataset[[column]]))
dataset_master_copy[[column]]
View(head(dataset_master_copy[[column]]))
View(head(dataset[[column]])))
View(head(dataset[[column]]))
outcome_type
library('devtools')
use_package("Hmisc")
load_all()
self.check_dataset()
?self
library("misl")
library("misl")
misl()
misl
library(misl)
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE)
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE)
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE)
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE)
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = TRUE)
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = TRUE)
misl_imp
misl_modeling <- lapply(misl_imp, function(y){
stats::lm(TotChol ~ Age + Weight + Height + Smoke100 + Education, data = y)
})
summary(mice::pool(misl_modeling))
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
plan(list(sequential,sequential))
library('fture')
library('futre')
library("future")
plan(list(sequential,sequential))
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
message("tommy")
print("Tommy")
?message
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_glmnet", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
misl_imp
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = c("Lrnr_mean", "Lrnr_mean"), con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
update.packages("sl3")
remotes::install_github("tlverse/sl3")
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
impute_mode(c(1,1,2,3))
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
impute_mode(nhanes$Education)
as.character(impute_mode(nhanes$Education))
load_all()
misl_imp <- misl(nhanes, maxit = 2, m = 2, quiet = FALSE, cat_method = "Lrnr_mean", con_method = "Lrnr_mean", bin_method = "Lrnr_mean")
misl_imp
