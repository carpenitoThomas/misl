misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_no_paralell <- end_sequential - start_sequential
elapsed_time_paralell
elapsed_time_no_paralell
load_all()
library('devtools')
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost", "Lrnr_randomForest"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_randomForest" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_no_paralell <- end_sequential - start_sequential
elapsed_time_paralell
elapsed_time_no_paralell
?plan
?future::multisession
availableCores()
library("future")
availableCores()
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
cpus_physical
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost", "Lrnr_randomForest"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_randomForest" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_paralell
elapsed_time_no_paralell
time_sl3_native_multicore
speed_outcome <- "Length"
speed_covars <- colnames(abalone)[-which(names(abalone) == speed_outcome)]
speed_task <- make_sl3_Task(
data = abalone,
covariates = speed_covars,
outcome = speed_outcome
)
speed_lrnr_glmnet <- make_learner(Lrnr_glmnet)
speed_lrnr_glm <- make_learner(Lrnr_glm)
speed_lrnr_ind_binomial<- make_learner(Lrnr_independent_binomial)
speed_lrnr_mean <- make_learner(Lrnr_mean)
speed_lrnr_randomforest <- make_learner(Lrnr_randomForest)
speed_lrnr_randomforest2 <- make_learner(Lrnr_randomForest)
speed_lrnr_randomforest3 <- make_learner(Lrnr_randomForest)
speed_lrnr_xgboost <- make_learner(Lrnr_xgboost)
speed_stack_learners <- make_learner(
Stack,
speed_lrnr_glm,
speed_lrnr_mean,
speed_lrnr_randomforest,
speed_lrnr_randomforest2,
speed_lrnr_randomforest3
)
speed_stack <- Lrnr_sl$new(
learners = speed_stack_learners
)
original_fit_time <- system.time({
set.seed(1234)
original_fit <- speed_stack$train(speed_task)
})
slow_test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_sequential <- system.time({
sched <- Scheduler$new(slow_test, SequentialJob)
cv_fit <- sched$compute()
})
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
plan(multisession, workers = cpus_physical)
test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_multicore <- system.time({
set.seed(1234)
sched <- Scheduler$new(test, FutureJob, nworkers = cpus_physical,
verbose = FALSE)
cv_fit <- sched$compute()
})
library('tidyverse')
library("sl3")
library("delayed")
library("future")
speed_outcome <- "Length"
speed_covars <- colnames(abalone)[-which(names(abalone) == speed_outcome)]
speed_task <- make_sl3_Task(
data = abalone,
covariates = speed_covars,
outcome = speed_outcome
)
speed_lrnr_glmnet <- make_learner(Lrnr_glmnet)
speed_lrnr_glm <- make_learner(Lrnr_glm)
speed_lrnr_ind_binomial<- make_learner(Lrnr_independent_binomial)
speed_lrnr_mean <- make_learner(Lrnr_mean)
speed_lrnr_randomforest <- make_learner(Lrnr_randomForest)
speed_lrnr_randomforest2 <- make_learner(Lrnr_randomForest)
speed_lrnr_randomforest3 <- make_learner(Lrnr_randomForest)
speed_lrnr_xgboost <- make_learner(Lrnr_xgboost)
speed_stack_learners <- make_learner(
Stack,
speed_lrnr_glm,
speed_lrnr_mean,
speed_lrnr_randomforest,
speed_lrnr_randomforest2,
speed_lrnr_randomforest3
)
speed_stack <- Lrnr_sl$new(
learners = speed_stack_learners
)
original_fit_time <- system.time({
set.seed(1234)
original_fit <- speed_stack$train(speed_task)
})
slow_test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_sequential <- system.time({
sched <- Scheduler$new(slow_test, SequentialJob)
cv_fit <- sched$compute()
})
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
plan(multisession, workers = cpus_physical)
test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_multicore <- system.time({
set.seed(1234)
sched <- Scheduler$new(test, FutureJob, nworkers = cpus_physical,
verbose = FALSE)
cv_fit <- sched$compute()
})
time_sl3_native_multicore
time_sl3_native_sequential
original_fit_time
time_sl3_native_multicore
time_sl3_native_multicore * 3
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
plan(multisession, workers = cpus_physical)
test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_multicore <- system.time({
for(i in 1:3){
set.seed(1234)
sched <- Scheduler$new(test, FutureJob, nworkers = cpus_physical,
verbose = FALSE)
cv_fit <- sched$compute()
}
})
time_sl3_native_multicore
original_fit_time <- system.time({
for(i in 1:3){
set.seed(1234)
original_fit <- speed_stack$train(speed_task)
}
})
original_fit_time
for(i in 1:3){
print(i)
}
rm(original_fit)
original_fit_time <- system.time({
for(i in 1:3){
set.seed(1234)
original_fit <- speed_stack$train(speed_task)
rm(original_fit)
}
})
original_fit_time
time_sl3_native_multicore
cv_fit$coefficients
original_fit
original_fit_time <- system.time({
for(i in 1:3){
set.seed(1234)
original_fit <- speed_stack$train(speed_task)
}
})
time_sl3_native_multicore
time_sl3_native_sequential
original_fit
original_fit_time
original_fit$coefficients
cv_fit$coefficients
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
plan(multisession, workers = cpus_physical)
test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_multicore <- system.time({
for(i in 1:3){
print("here")
set.seed(1234)
sched <- Scheduler$new(test, FutureJob, nworkers = cpus_physical,
verbose = TRUE)
cv_fit <- sched$compute()
}
})
speed_stack_learners <- make_learner(
Stack,
speed_lrnr_glm,
speed_lrnr_mean,
speed_lrnr_randomforest,
)
speed_stack_learners <- make_learner(
Stack,
speed_lrnr_glm,
speed_lrnr_mean,
speed_lrnr_randomforest
)
speed_stack <- Lrnr_sl$new(
learners = speed_stack_learners
)
cpus_physical <-as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
plan(multisession, workers = cpus_physical)
test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_multicore <- system.time({
for(i in 1:3){
print("here")
set.seed(1234)
sched <- Scheduler$new(test, FutureJob, nworkers = cpus_physical,
verbose = TRUE)
cv_fit <- sched$compute()
}
})
slow_test <- delayed_learner_train(speed_stack, speed_task)
time_sl3_native_sequential <- system.time({
sched <- Scheduler$new(slow_test, SequentialJob, verbose = TRUE)
cv_fit <- sched$compute()
})
time_sl3_native_sequential
time_sl3_native_multicore
?delayed_fn
?delayed_fun
print("****")
load_all()
load_all()
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost", "Lrnr_randomForest"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_randomForest" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
version()
R.version()
R.version
R.version.string
?install.packages
install.packages("packra")
install.packages("packrat")
?rtracklayer
install.packages("rtracklayer")
?remotes::install_github()
availableCores()
R.version
?packrat
?packrat::restore()
?save
save(abalone, "ABALONE.Rdata")
save(abalone, file = "ABALONE.Rdata")
pwd
getwd()
load("/Users/thomascarpenito/Documents/programming/misl/ABALONE.Rdata")
elapsed_time_paralell
elapsed_time_no_paralell
elapsed_time_paralell <- Sys.time() - Sys.time()
elapsed_time_paralell
elapsed_time_no_paralell <- Sys.time() - Sys.time()
elapsed_time_no_paralell
save(c(elapsed_time_paralell, elapsed_time_no_paralell), file = "testing.Rdata")
save(elapsed_time_paralell, elapsed_time_no_paralell, file = "testing.Rdata")
load("/Users/thomascarpenito/Documents/programming/misl/testing.Rdata")
elapsed_time_no_paralell
?install.packages
