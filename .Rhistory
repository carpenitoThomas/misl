results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = FALSE,
#con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost"),
con_method = c("Lrnr_mean", "Lrnr_glm"),
#bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_ranger" ),
bin_method = c("Lrnr_mean", "Lrnr_glm"),
#cat_method = c("Lrnr_mean", "Lrnr_independent_binomial")
cat_method = c("Lrnr_mean"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start <- Sys.time()
simulation_results <- simulation(1)
end <- Sys.time()
elapsed_time_no_paralell <- end - start
elapsed_time_no_paralell
elapsed_time_paralell
cpus_physical <- as.numeric(system("sysctl -n hw.physicalcpu", intern = TRUE))
cpus_physical
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = FALSE,
#con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost"),
con_method = c("Lrnr_mean", "Lrnr_glm"),
#bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_ranger" ),
bin_method = c("Lrnr_mean", "Lrnr_glm"),
#cat_method = c("Lrnr_mean", "Lrnr_independent_binomial")
cat_method = c("Lrnr_mean"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start <- Sys.time()
simulation_results <- simulation(1)
end <- Sys.time()
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = TRUE,
#con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost"),
con_method = c("Lrnr_mean", "Lrnr_glm"),
#bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_ranger" ),
bin_method = c("Lrnr_mean", "Lrnr_glm"),
#cat_method = c("Lrnr_mean", "Lrnr_independent_binomial")
cat_method = c("Lrnr_mean"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start <- Sys.time()
simulation_results <- simulation(1)
end <- Sys.time()
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_ranger" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_no_paralell <- end_sequential - start_sequential
elapsed_time_no_paralell
elapsed_time_paralell
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost", "Lrnr_randomForest"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_randomForest" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_no_paralell <- end_sequential - start_sequential
elapsed_time_paralell
elapsed_time_no_paralell
?FutureJob
availableCores()
future::availableCores()
parallel::detectCores()
?plan
?multisession
?Scheduler
load_all()
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_paralell
install.packages("naniar")
library('naniar')
naniar::replace_with_na(iris, list(Species="setosa"))
str(iris)
colSums(is.na(iris))
iris %>% naniar::replace_with_na_if(is.factor, ~.x %in% "setosa")
a <- iris %>% naniar::replace_with_na_if(is.factor, ~.x %in% "setosa")
colSums(is.na(a))
str(a)
nrow(a)
View(a)
?replace_with_na_if
str(iris)
load_all()
# The purpose of this document is to test out the misl simulations using the abalone data.
# First, prepare the abalone data
library('misl')
library('tidyverse')
library("sl3")
library('mice')
abalone <- read.csv("raw-data/abalone.data", header=FALSE)
colnames(abalone) <- c("Sex", "Length", "Diameter", "Height", "Whole_Weight", "Shuck_Weight", "Viscera_Weight", "Shell_Weight", "Rings")
abalone <- abalone %>%
mutate(Age = Rings + 1.5,
Sex = as.factor(Sex),
Older_12 = as.integer(Age > 12)
) %>%
select(-c(Rings, Age))
abalone <- as_tibble(abalone)
## For this procedure we will:
#### 1. Generate a linear model predicting the outcome of interest
#### 2. Replace the outcome with the predicted values from the model
#### 3. Begin a loop (1000 times that...)
###### 1. Amputes the dataset under a specified mechanism
###### 2. Performs the imputation under mean, mice, misl, etc...
###### 3. Pools the results from the multiply imputed datasets
###### 4. Stores the results in a list
#### 4. Repeat steps 3-6 1,000 times.
#### 5. Obtain results
## 1. Generate a linear model predicting the outcome of interest
#### Whole_Weight = Sex + Length + Diameter + Height +  Older_12
original_model <- lm(Whole_Weight ~ Sex + Length + Diameter + Height + Older_12, data = abalone)
predictions <- predict(original_model)
## 2. Replace the outcome with the predicted values from the model
abalone_model_predictions <- abalone %>%
select(c(Sex, Length, Diameter, Height, Older_12))
abalone_model_predictions$Whole_Weight_Pred <- predictions
truth_model <- lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = abalone_model_predictions)
mypatterns <- expand.grid(Sex = 0:1, Length = 0:1, Diameter = 0:1, Height = 0:1, Older_12 = 0:1, Whole_Weight_Pred = 0:1)
mypatterns <- mypatterns[rowSums(mypatterns) != 0,]
## 3. Begin a loop (1000 times that...)
simulation <- function(runs = 2, multisession = FALSE){
# First, setup our results array
results <- array(NA, dim = c(3, runs, 3 ))
dimnames(results) <- list(c("Mean.Imp", "Mice.Imp", "Misl.Imp"),
as.character(1:runs),
c("Estimate", "2.5 %", "97.5 %")
)
# Next begin our run through each of the simulations
for(run in 1:runs){
# We begin first with amputing our data
amputed_mads <- ampute(abalone_model_predictions,
prop = .60,
patterns = mypatterns,
mech = "MCAR")
# We can then begin the imputation
amputed_data <- amputed_mads$amp
mean_imputations <- mice(amputed_data, method = "mean")
mice_imputations <- mice(amputed_data)
misl_imputations <- misl(amputed_data,
multisession = multisession,
con_method = c("Lrnr_mean", "Lrnr_glm", "Lrnr_xgboost", "Lrnr_randomForest"),
bin_method = c("Lrnr_mean", "Lrnr_xgboost", "Lrnr_glm", "Lrnr_randomForest" ),
cat_method = c("Lrnr_mean", "Lrnr_independent_binomial"))
# We can then begin the fitting process
mean_fit <- with(mean_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
mice_fit <- with(mice_imputations, exp = lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12))
misl_fit <- lapply(misl_imputations, function(y){
stats::lm(Whole_Weight_Pred ~ Sex + Length + Diameter + Height + Older_12, data = y)
})
# The results can be pooled
mean_pool <- summary(mice::pool(mean_fit), conf.int = TRUE)
mice_pool <- summary(mice::pool(mice_fit), conf.int = TRUE)
misl_pool <- summary(mice::pool(misl_fit), conf.int = TRUE)
# Finally, we can append our results to the array
results[1, run,] <- as.numeric(mean_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[2, run,] <- as.numeric(mice_pool[4, c("estimate", "2.5 %", "97.5 %")])
results[3, run,] <- as.numeric(misl_pool[4, c("estimate", "2.5 %", "97.5 %")])
}
results
}
start_multisession <- Sys.time()
simulation_results_multisession <- simulation(1, multisession = TRUE)
end_multisession <- Sys.time()
start_sequential <- Sys.time()
simulation_results_sequential <- simulation(1, multisession = FALSE)
end_sequential <- Sys.time()
elapsed_time_paralell <- end_multisession - start_multisession
elapsed_time_no_paralell <- end_sequential - start_sequential
elapsed_time_paralell
elapsed_time_no_paralell
